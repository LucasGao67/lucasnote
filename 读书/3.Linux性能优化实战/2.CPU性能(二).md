[toc]



# 5. 软中断

## 什么是中断

> 本质上，中断是一种电信号，在CSApp中作者称为异常。
>
> 它用来响应设备的一些事件。



一般来说中断有2种

1. cpu内部中断，即执行软件中断指令INT或遇到软件陷阱而产生的中断，它们的中断类型号已由CPU规定好。比如信号就属于CPU内部中断。
2. IO设备产生，比如磁盘ready。对应IRQ14

当系统中产生中断后，我们的CPU就要放下手头的工作，转而处理中断内容。

一般来说我们去处理一件事情都是需要时间的，但是中断内本质上就是电信号，那么如果当前中断没有处理完，又来了新的中断，此时电信号不会变化，就会导致中断丢失！！！所以我们就需要尽快处理中断请求，因此Linux设计了一种架构，将中断分为2部分

- 上半部分，用于快速处理，此时位于中断模式，也就算不能再接收中断。
- 下半部分，处理真正耗时的工作，此时可以接收新的中断，也可被新的中断打断。

## 软中断

上面说了，下半部分处理真正耗时的工作，也就是我们的软中断，它其实就是内核线程。

> 一个网卡接收数据的例子，当网卡接到数据之后
>
> 对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。
>
> 而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

查看系统中的软中断

```shell
➜  ~ cat /proc/softirqs
                    CPU0       CPU1
          HI:          2          3
       TIMER:       3219      10221
      NET_TX:          0          1
      NET_RX:        921        950
       BLOCK:       5401          0
    IRQ_POLL:          0          0
     TASKLET:         75          9
       SCHED:       2947      10084
     HRTIMER:          0          0
         RCU:       6468       9392
```

查看软中断对应的线程

```shell
➜  ~ ps aux | grep softirq
root         9  0.0  0.0      0     0 ?        S    21:26   0:00 [ksoftirqd/0]
root        17  0.0  0.0      0     0 ?        S    21:26   0:00 [ksoftirqd/1]

# 注意，这些线程的名字外面都有中括号，这说明 ps 无法获取它们的命令行参数（cmline）。一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。
```



## 拓展

1. sys flood 导致软中断升高 https://time.geekbang.org/column/article/72147





## 参考文章

1. https://www.jianshu.com/p/52a3ee40ea30
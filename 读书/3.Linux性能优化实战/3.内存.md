[toc]

# 内存基础

> 学习的目的
>
> 我们工作中，接触最多的可能就是内存了。内存也很可能是性能瓶颈或者异常所在，所以这篇的目标就是掌握内存工作的原理，问题归纳分类，快速定位！！！



> 系统直接打交道的是虚拟内存，由MMU管理

我们可以使用top查看内存使用情况

- VIRT 进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内

- RES 常住内存大小，也就算进程时机使用的物理内存大小，但不包括Swap和共享内存

- SHR 共享内存大小，

  

## Swap是什么

> 交换分区

Swap其实就是把一块磁盘空间当做内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存的时候，再从磁盘读取这些数据到内存中（换入）



## Buffer & Cache

> 前置: 磁盘和文件的区别
>
> 磁盘：磁盘是一个块设备
>
> 文件：文件是文件系统，和磁盘打交道。



buffers是对原始磁盘块的临时存储，用来缓存磁盘数据。

cache是对文件系统的缓存，用来缓存文件读取的数据。



> 感觉目前来说理解这块意义不大，我们一般应该都是跟文件系统打交道，并且目前来看这块和工作契合较少。









## 存在的问题

1. 共享内存？
2. 虚拟内存虽然不占用物理内存，那它一点内存都不占吗？
   1. mmu
   2. tlb 







# 内存的分配

>  // TODO
>
> golang 的 tcmalloc



# 内存的回收

> 谁污染谁治理，
>
> 内存的回收切记完成，当然现在高阶语言也都支持了自动回收，不过了解内存回收的相关东西还是有利于排查问题的



> TODO
>
> GC算法



### 如果定位内存泄漏

memleak

使用这个函数观察认为可能存在的内存泄漏，然后查看内存分配，通过memleak可以定位到具体分配内存的函数，当然实际生产中会比这个复杂的多，但是万变不离其宗，有了正确的方向，再去追问题。





## 直接内存回收

有新的大块内存分配请求，但是剩余内存不足。这个时候系统就需要回收一部分内存（比如前面提到的缓存），进而尽可能地满足新内存请求。这个过程通常被称为

## 定期回收

> kswapd0 完成

为了衡量内存使用情况，kswapd0定义了三个内存阈值（watermark,也称为水位）

- 页最小阈值 pages_min
- 页低阈值 pages_low
- 页高阈值 pages_high

![img](http://picgo.vipkk.work/20200613205335.png)



`kswapd0`会定期扫描内存的使用情况，并根据具体情况进行回收操作

- 剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。
- 剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。
- 剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。
- 剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。





## SWAP

> 在内存不足的年代，swap起了很大的作用，但是现在大家有钱了，有 内存了，swap摇身一变，缓存内存数据不丢失，这样的话当我们关机重启时 可以快速重启

为什么说swap也是一种内存回收

应用程序动态分配的堆内存，也就算我们的匿名页，因为还在使用，所以不能直接被回收，但是有可能这些内存不频繁，所以可以利用swap机制，把这块内存放到硬盘中，然后就可以释放内存了。



总体来说，但内存不够的时候系统会尝试使用swap机制，但是这是个比较古老的机制，并且目前工作中大多是swap off,所以这块有信息可以做个了解，笔者认为工作中用处应该不大。



### NUMA特殊case

> 作者的例子，笔者没遇到过

有时候会发现swap升高，但是剩余内存还有很多。

这种情况下，可能是在NUMA架构下，多个处理器被划分到不同的node上，且每个node都拥有自己的本地内幕才能空间。

这样虽然总体剩余很多，但有可能单个CPU剩余不足。



可以使用`numactl --hardware` 命令查看node节点情况
















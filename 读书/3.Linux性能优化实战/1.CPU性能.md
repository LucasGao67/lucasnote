[toc]

---

> 命令工具只是一部分，不是全部。



# 1. 平均负载

> 在开发的时候，每当电脑风扇响起，鼠标不再响应的时候，我就经常会 `命令行->top->kill`三连。

使用top我们可以找到当前负载比较高的进程然后kill。

但是我们也可以使用uptime命令，来观察下平均负载，从而对系统整体有个认知。

```shell
➜  ~ uptime
 1:03  up 5 days, 15:31, 3 users, load averages: 2.08 2.00 2.45
```

uptime前三列输出分别为 当前系统时间、系统运行的持续时间以及登录的用户数。

而后面三个值就是我们系统的平均负载，分别表示过去1分钟、5分钟、15分钟的平均负载。如果我们把平均负载记录，绘制成图的话，笔者的大概这样

<img src="http://picgo.vipkk.work/20200527010649.png" alt="image-20200527010649684" style="zoom:50%;" />

这是过去24小时的平均负载，可以看到大部分在2，然后有几个毛刺甚至到了18。我们直观上可以感觉到越低越好，但是从细节分析，这些平均负载的定义到底是什么呢？ **是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，即平均活跃进程数**

> 可运行状态：是指正在CPU的进程或者正在等待CPU的进程
>
> 下图中的R就是可运行状态 `ps -ux`
>
> ![image-20200527011939035](http://picgo.vipkk.work/20200527011939.png)

>不可中断状态：是指正处于内核态中的进程，并且不可被打断。比如IOwait。
>
>ps中看到的D就是这种，参考[^1]。



如上，如果每个CPU上刚好运行着一个进程，那么这样每个CPU都可以得到充分的利用，这应该是最理想的状态了。(ps. golang GMP 中的P设计的个数限制)

那么回到刚刚的uptime命令，如果平均负载是2的话，意味着什么呢

- 2个CPU的系统上，刚好完全占有
- 4个CPU的系统上，有CPU有50%的空闲
- 1个CPU上，有一半的CPU竞争不到CPU。



既然负载跟CPU个数相关，那么我们应该如何查看CPU的个数呢？可以使用`cat /proc/cpuinfo`中了解机器详细信息，参考[^2]

例如电脑为2核机器，如下图

```shell
➜  ~ # 物理CPU数
➜  ~ cat /proc/cpuinfo| grep "physical id"
physical id	: 0
physical id	: 1
➜  ~ # 查看每个物理 cpu 中 核心数(core 数)：
➜  ~ cat /proc/cpuinfo | grep "cpu cores"
cpu cores	: 1
cpu cores	: 1
➜  ~ # 查看总的逻辑 cpu 数
➜  ~ cat /proc/cpuinfo| grep "processor"
processor	: 0
processor	: 1
➜  ~ # 查看 cpu 型号：
➜  ~ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
      2  Intel(R) Xeon(R) Gold 6161 CPU @ 2.20GHz
```



## 平均负载VSCPU使用率

> 在学习博客之前，一直以为负载就CPU使用率

平均负载不仅仅包括CPU使用还有上面提到的D进程。针对IO密集型的服务，我们的CPU使用率并不高，但是平均负载也不低。



## 案例分析[^3]

> 这里主要用到的命令
>
> - stress 
> - mpstat
> - pidstat







# 参考引用

[^1]: https://mp.weixin.qq.com/s/E5X9U7QIGnLCd4ETn2Ldlw
[^2]: https://zhuanlan.zhihu.com/p/86855590
[^3]: https://time.geekbang.org/column/article/69618